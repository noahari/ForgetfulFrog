<!DOCTYPE html>

<html>

  <head>

    <title>Forgetful Frog</title>

    <meta name = "viewport" content = "width=device-width, initial-scale=1.0">
    <script src="lib/jspsych-6.0.5/jspsych.js"></script>
    <script src="lib/jspsych-6.0.5/plugins/jspsych-html-button-response.js"></script>
    <!--<link href="../jspsych-6.0.5/css/jspsych.css" rel="stylesheet" type="text/css"></link>-->
    <link href = "tiling.css" rel = "stylesheet" type = "text/css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  </head>

  <body>
    
    <script src = "procgen.js" type = "text/javascript"></script>
    <script src="memory-map.js"></script>
    <div id="buttonbar">
      <!--bgm hideaway is a forcible play of a sound, which browsers don't like, its fine but should be fixed for professionalism later-->
      <button id='bgmhideaway' onclick="startBGM"></button>
      <i class="material-icons" id='sound' onclick="toggleSounds()">volume_up</i>
      <i class="material-icons" id='music' onclick="toggleBGM()">music_note</i>
      <i class="material-icons" id='fullscreenh' onclick="toggleFullScreen()">fullscreen</i>
      <img id="profile" src='img/levelCircle.png'>
      <audio id='hop' src='audio/hop.wav'></audio>
      <audio id='ding' src='audio/ding.wav'></audio>
      <audio id='splash' src='audio/splash.wav'></audio>
      <audio id='bgm' src='audio/bga2.wav' autoplay loop></audio>
    </div>
    <div id="tutorial">
      <div id='tutbox'>
        <p id='tuttxt'>Hop to the fly using either the arrow keys or the arrows in the bottom right-hand corner!</p>
      </div>
    </div>
    <div id='circlewrap'>
      <img id='levelCircle' src='img/levelCircleF.png'>
      <div id='lvltxtC'>Level<br>1</div>
    </div>
    <div id="game"></div>
  
  </body>
  <script>
    //jspsych timeline
    var timeline = [];
    //variable containing # of tries user gets before game over
    var lives = 10000;
    //variable that when it hits a certain value, difficulty increases
    //init to -n where n is # of tutorial stages
    var spiketrack = -2;
    var totalwins = 0;
    var totalfails = 0;
    var attempts = 0;
    //variable containing the number of failures since the last difficulty drop
    var fails = 0;
    //variable that contains the maximum amount of time a user gets to memorize
    var timemax = 3.5;
    //variable that contains the minimum amount of time a user gets to memorize
    var timemin = 2.5;
    //variable that stores whether the game is in tutorial mode, which ensures a number of gamerule changes
    //tutorial mode includes preset map loading, no lives lost, and no pad dissappearance
    var tutover = false;
    var score = 0;
    var goal = 50;
    var endless = true;
    var silenced = false;
    //true to save data to db
    var savingSwitch = false;
    var gameSessionID = null;
    var userName = null;

    var bgm = null;//new Audio("audio/bga2.wav");
    //bgm.id = 'bgm';
    //bgm.load();

    //helper function that starts the background music if its not already started
    //"BROWSER INSECURE" in current implementation, 
    startBGM = function(){
      if(!silenced){
        bgm.play();
      }
    }

    //mutes and pauese music or unmutes and plays music depending on current state
    toggleBGM = function(){
      if(!bgm.paused){
        bgm.pause();
        silenced = true;
        document.getElementById('music').innerHTML = "music_off";
      }
      else{
        bgm.currentTime = 0;
        bgm.play();
        silenced = false;
        document.getElementById('music').innerHTML = "music_note";
      }
    }

    //This function toggles fullscreen settings using request and cancel depending on current view
    toggleFullScreen = function(){
      //paramevent.stopPropagation();
      var doc = window.document;
      var docEl = doc.documentElement;
    
      var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
      var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

      if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
        document.getElementById('fullscreenh').innerHTML = "fullscreen_exit";
        requestFullScreen.call(docEl);
      }
      else {
        document.getElementById('fullscreenh').innerHTML = "fullscreen";
        cancelFullScreen.call(doc);
      }
    }

    var hop = null;
    var ding = null;
    var splash = null;
    
    initSounds = function(){/*
      hop = document.createElement("AUDIO");
      hop.src = "audio/hop.wav";
      ding = document.createElement("AUDIO");
      ding.src = "audio/ding.wav";
      splash = document.createElement("AUDIO");
      splash.src = "audio/splash.wav"*/
      hop = document.getElementById("hop");
      hop.volume = .5;
      ding = document.getElementById("ding");
      splash = document.getElementById("splash");
      bgm = document.getElementById("bgm"); 
      bgm.volume = 0.7;
      if(bgm.paused && !silenced){
        bgm.play();
      }
    }

    toggleSounds = function(){
      if(hop == null || splash == null || ding == null || bgm == null){
        initSounds();
      }
      if(hop.volume == .5){
        hop.volume = 0.0;
        document.getElementById('sound').innerHTML = "volume_mute";
      }
      else{
        hop.volume = .5;
        document.getElementById('sound').innerHTML = "volume_up";
      }
      if(ding.volume == 1.0){
        ding.volume = 0.0;       
      }
      else{
        ding.volume = 1.0;
      }
      if(splash.volume == 1.0){
        splash.volume = 0.0;       
      }
      else{
        splash.volume = 1.0;
      }
    }
    
    function failcheck(){
      var ts = jsPsych.data.get().last(1).filter({trial_type: 'memory-map'}).filter({success: false}).count();
      if((ts == 1)&&tutover){
        lives--;
        fails++;
        totalfails++;
        if(fails >= 3){
          timemax = 3.5;
          timemin = 2.5;
          spiketrack = 0;
          if(trial.exit_length>5){
            trial.exit_length = trial.exit_length - 1;
            document.getElementById("lvltxtC").innerHTML = "Level<br>"+(trial.exit_length-4);
            document.getElementById("lvltxtC").style.color = "red";
            document.getElementById('circlewrap').style.opacity = 0;
            window.requestAnimationFrame(fadeInCircle);
          }
          fails = 0;
        }
        if(score>0){
          score = score-(fails*5+5);
        }
        if(score<0){
          score = 0;
        }
      }
    }

    function spikecheck(){
      var ts = jsPsych.data.get().last(1).filter({trial_type: 'memory-map'}).filter({success: true}).count();
      if((ts == 1)&&(spiketrack>=0)&&tutover){
        timemax = timemax - .5;
        timemin = timemin - .5;
        spiketrack++;
        totalwins++;
        if(totalwins > 0){
          if(totalfails == 0){
            score = 100;
          }
          else{
            score = (totalwins/totalfails)*100;
          }
        }
        else{
          score = 0;
        }
      }
      if(spiketrack >= 5){
        spiketrack = 0;
        fails = 0;
        trial.exit_length = trial.exit_length + 1;
        //must be set .5 higher since .5 subtracted after
        timemax = 3.5;
        timemin = 2.5;
        document.getElementById("lvltxtC").innerHTML = "Level<br>"+(trial.exit_length-4);
        document.getElementById("lvltxtC").style.color = "green";
        document.getElementById('circlewrap').style.opacity = 0;
        window.requestAnimationFrame(fadeInCircle);
      }
    }

    var faded = false;
    fadeInCircle = function(){
      var cw = document.getElementById('circlewrap');
      cw.style.opacity = parseFloat(cw.style.opacity) + .04;
      if(cw.style.opacity < 1){
        window.requestAnimationFrame(fadeInCircle);
      }
      else{
        window.requestAnimationFrame(fadeOutCircle);
      }
    }
    fadeOutCircle = function(){
      var cw = document.getElementById('circlewrap');
      cw.style.opacity = parseFloat(cw.style.opacity) - .04;
      if(cw.style.opacity > 0){
        window.requestAnimationFrame(fadeOutCircle);
      }
    }

    var start = null;
    delay = function(int,func){
      if(start == null){
        start = Date.now();
      }
      var progress = Date.now() - start;
      if(progress < int){
        //anon func t prevent glob
        id = requestAnimationFrame(function(timestamp){
          delay(int,func);
        });
        RAFid.push(id);
      }
      else{
        start = null;
        func();
        return;
      }
    }

    //runs after a map is completed to determine if a new map should be generated
    function postMap(){
      //check if difficulty should decrease
      failcheck();
      //check if difficulty should increase
      spikecheck();
      //if the goal of map clears isn't reached, or endless mode is enabled then make a new map
      if(((totalwins < goal)||(endless))&&(tutover)){
        jsPsych.addNodeToEndOfTimeline(trial, function(){});
      }
      else{
        if(tutover){
          //Allow continue?
        }
      }
      if(tutover){
        attempts++;
      }
    }

    //preloads images specified in an array and returns the loaded list
    //useful for optimizing load times and preventing ghost graphics
    function preloadImages(array) {
    if (!preloadImages.list) {
        preloadImages.list = [];
    }
    var list = preloadImages.list;
    var loadedlist = [];
    for (var i = 0; i < array.length; i++) {
        var img = new Image();
        img.onload = function() {
            var index = list.indexOf(this);
            if (index !== -1) {
                list.splice(index, 1);
            }
        }
        list.push(img);
        img.src = array[i];
        loadedlist.push(img);
    }
    return loadedlist;
  }

  //generates the sprite sheet for the game
  var sprites = preloadImages(["img/frog.png", "img/frogL.png", "img/frogR.png", "img/frogD.png", "img/frogJ.png", "img/frogLJ.png", "img/frogRJ.png", "img/frogDJ.png", "img/padonly.svg", "img/flypad.png", "img/check.png", "img/splash1.svg", "img/splash2.svg", "img/splash3.svg", "img/sparkle1.svg", "img/sparkle2.svg"]);

  //jsPsych definition for tutorial level 1
  var tut1 = {
      type: "memory-map",
      game_map: [1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,0,2,1,1,1,1,
                 1,1,1,0,1,1,1,1,1,
                 1,1,1,0,-1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,],
      tutorial: true,
      row_length: 9,
      column_height: 9,
      lives: function(){return lives;},
      consecutivewins: function(){return spiketrack},
      wins: function(){return totalwins},
      fails: function(){return totalfails},
      sprites: function(){return sprites},
      on_start: function(){
        if(gameSessionID == null){
          //needs checking for duplicates
          gameSessionID = jsPsych.randomization.randomID(32);
        }
        if(userName == null){
          //needs checking for duplicates
          userName = "anon-"+jsPsych.randomization.randomID(32);
        }
      },
      on_finish: function(){
        //if the player failed the tutorial level, re-push the same level, otherwise push the next tutorial level
        var ts = jsPsych.data.get().last(1).filter({trial_type: 'memory-map'}).filter({success: false}).count();
        if(ts == 1){
          jsPsych.addNodeToEndOfTimeline(tut1, function(){});
        }
        else{
          document.getElementById("tuttxt").innerHTML = "The lilypads will disappear after you hop or wait too long, remember the path!"
          jsPsych.addNodeToEndOfTimeline(tut2, function(){});
        }
      }
    };

  //jsPsych definition for tutorial level 2
  var tut2 = {
      type: "memory-map",
      game_map: [1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,1,0,0,2,1,1,
                 1,1,1,1,0,1,1,1,1,
                 1,1,1,1,-1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,
                 1,1,1,1,1,1,1,1,1,],
      //specifies tutorial is "over" since this is the last tutorial level and pads must disappear
      tutorial: false,
      lives: function(){return lives;},
      consecutivewins: function(){return spiketrack},
      wins: function(){return totalwins},
      fails: function(){return totalfails},
      sprites: function(){return sprites},
      on_finish: function(){
        //if the player failed the tutorial level, push the same tutorial level, otherwise push the true game level
        var ts = jsPsych.data.get().last(1).filter({trial_type: 'memory-map'}).filter({success: false}).count();
        if(ts == 1){
          jsPsych.addNodeToEndOfTimeline(tut2, function(){});
        }
        else{
          //reset spike and fails since game is actually beginning here
          fails = 0;
          spiketrack = 0;
          jsPsych.addNodeToEndOfTimeline(trial, function(){});
        }
      }
    };

  //stores jsPsych data from all trails to bgl xml
  function saveGameplayData(user, game, session, trial){
    var payload = {
      UserID: user,
      GameID: game,
      SessionID: session,
      TrialData: trial
    }
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://api.thebraingamelab.org/savegameplaydata');
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onload = function() {
      if(xhr.status == 200){
      }
    };
    xhr.send(JSON.stringify(payload));     
  }

  //the jsPsych declaration for the prototypical "game level" that players continously play through
  var trial = {
      type: "memory-map",
      exit_length: 5,
      row_length: function(){
      },
      column_height: 15,
      lives: function(){return lives;},
      consecutivewins: function(){return spiketrack-1;},
      score: function(){return score;},
      wins: function(){return totalwins},
      fails: function(){return totalfails},
      sprites: function(){return sprites},
      attempts: function(){return attempts},
      blackout_speed: function(){
        return ((Math.random() * (timemax - timemin))+timemin)*1000;
      },
      on_start: function(trial){
        tutover = true;
        //nested conditional to scale game size depending on exit_length difficulty
        if(trial.exit_length>19){
          if(trial.exit_length>28){
            if(trial.exit_length>39){
              trial.row_length = 15;
              trial.column_height = 15;
            }
            else{
              trial.row_length = 13;
              trial.column_height = 13;
            }
          }
          else{
            trial.row_length = 11;
            trial.column_height = 11;
          }
        }
        else{
          trial.row_length = 9;
          trial.column_height = 9;
        }
      },
      on_finish: function(trial){
        if(savingSwitch){
          saveGameplayData(userName,"forgetful-frog",gameSessionID,trial);
          console.log("USER DATA WRITTEN");
        }
        else{
          console.log("DATA WRITE: SKIPPED");
        }
        console.log("DATA: "+userName+", "+"forgetful-frog"+", "+gameSessionID);
      }
    };


  timeline.push(tut1);
  //begin game using jsPsych framework
  jsPsych.init({
  timeline: timeline,
  display_element: 'game',
      on_trial_finish: function(){
        postMap();
      },
      on_finish: function(){
          //jsPsych.data.displayData();
          //display_element.innerHTML = "GAME OVER";
          console.log("GAME OVER! this should only occur on prolific");
        }
});

  </script>

</html>